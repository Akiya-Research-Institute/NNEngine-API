<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NNEngine: UTextureProcessFunctionLibrary Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NNEngine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_u_texture_process_function_library.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_u_texture_process_function_library-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">UTextureProcessFunctionLibrary Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for UTextureProcessFunctionLibrary:</div>
<div class="dyncontent">
<div class="center"><img src="class_u_texture_process_function_library__inherit__graph.png" border="0" usemap="#a_u_texture_process_function_library_inherit__map" alt="Inheritance graph"/></div>
<map name="a_u_texture_process_function_library_inherit__map" id="a_u_texture_process_function_library_inherit__map">
<area shape="rect" title=" " alt="" coords="5,80,216,107"/>
<area shape="rect" title=" " alt="" coords="25,5,196,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for UTextureProcessFunctionLibrary:</div>
<div class="dyncontent">
<div class="center"><img src="class_u_texture_process_function_library__coll__graph.png" border="0" usemap="#a_u_texture_process_function_library_coll__map" alt="Collaboration graph"/></div>
<map name="a_u_texture_process_function_library_coll__map" id="a_u_texture_process_function_library_coll__map">
<area shape="rect" title=" " alt="" coords="5,80,216,107"/>
<area shape="rect" title=" " alt="" coords="25,5,196,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0bb764699d2d0d0a719327a64798b17e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#a0bb764699d2d0d0a719327a64798b17e">getImageSize</a> (UTexture *inputTexture, FVector2D &amp;dimensions)</td></tr>
<tr class="separator:a0bb764699d2d0d0a719327a64798b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab5b0e53dcf82e3e4c222df0d5acd8f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#a2ab5b0e53dcf82e3e4c222df0d5acd8f">getInverseAffineMatFrom2Points</a> (const FVector2D &amp;center, const FVector2D &amp;topCenter, const float &amp;scalingFactor, <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;out_inverseAffineMat)</td></tr>
<tr class="separator:a2ab5b0e53dcf82e3e4c222df0d5acd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8f02132f0e27963372ee18b8cd68a1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#a9d8f02132f0e27963372ee18b8cd68a1">getInverseAffineMat</a> (const FVector2D &amp;center, const FVector2D &amp;orientation, const float &amp;size, <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;out_inverseAffineMat)</td></tr>
<tr class="separator:a9d8f02132f0e27963372ee18b8cd68a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad682284e8f4cbe974051a0f592c9a011"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#ad682284e8f4cbe974051a0f592c9a011">correctAspectRatio</a> (const FVector2D &amp;uvScalingFactor, const <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;affineMat, <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;correctedAffineMat)</td></tr>
<tr class="separator:ad682284e8f4cbe974051a0f592c9a011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67b71fc41cc516ca65299928182df89"><td class="memItemLeft" align="right" valign="top">static FVector2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#ae67b71fc41cc516ca65299928182df89">affineTransformPoint</a> (const <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;affineMat, const FVector2D &amp;point)</td></tr>
<tr class="separator:ae67b71fc41cc516ca65299928182df89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada28751aa2e2ce5f941617aaf21948a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#ada28751aa2e2ce5f941617aaf21948a7">affineTransformPoints</a> (const TArray&lt; FVector2D &gt; &amp;in_points, TArray&lt; FVector2D &gt; &amp;out_points, const <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> affineMat)</td></tr>
<tr class="separator:ada28751aa2e2ce5f941617aaf21948a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6644a473f81e2e5b0e790d470771fe07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#a6644a473f81e2e5b0e790d470771fe07">showImageWith2dPoints</a> (const TArray&lt; uint8 &gt; &amp;rawDataHxWxBGR, const TArray&lt; FVector2D &gt; &amp;overlayPoints, const int imageWidth, const int imageHeight, const int windowSize=700, const FString windowTitle=&quot;Debug&quot;, const bool denormalizePoints=true)</td></tr>
<tr class="separator:a6644a473f81e2e5b0e790d470771fe07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad99072ad474d0e52f072ec888645938"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#aad99072ad474d0e52f072ec888645938">showImageWith3dPoints</a> (const TArray&lt; uint8 &gt; &amp;rawDataHxWxBGR, const TArray&lt; FVector &gt; &amp;overlayPoints, const int imageWidth, const int imageHeight, const int windowSize=700, const FString windowTitle=&quot;Debug&quot;, const bool denormalizePoints=true)</td></tr>
<tr class="separator:aad99072ad474d0e52f072ec888645938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06fee097f93efea26e2e496f6b24407"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_texture_process_function_library.html#ad06fee097f93efea26e2e496f6b24407">convertToIntImage</a> (UPARAM(ref) TArray&lt; uint8 &gt; &amp;in_rawDataHxWxBGR, TArray&lt; int &gt; &amp;out_rawDataHxWxBGR, const int imageWidth, const int imageHeight)</td></tr>
<tr class="separator:ad06fee097f93efea26e2e496f6b24407"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae67b71fc41cc516ca65299928182df89" name="ae67b71fc41cc516ca65299928182df89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67b71fc41cc516ca65299928182df89">&#9670;&nbsp;</a></span>affineTransformPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FVector2D UTextureProcessFunctionLibrary::affineTransformPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;&#160;</td>
          <td class="paramname"><em>affineMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector2D &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Affine transform a point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">affineMat</td><td>Input matrix which represents affine transform </td></tr>
    <tr><td class="paramname">point</td><td>Point to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed point </dd></dl>

</div>
</div>
<a id="ada28751aa2e2ce5f941617aaf21948a7" name="ada28751aa2e2ce5f941617aaf21948a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada28751aa2e2ce5f941617aaf21948a7">&#9670;&nbsp;</a></span>affineTransformPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTextureProcessFunctionLibrary::affineTransformPoints </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FVector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FVector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a>&#160;</td>
          <td class="paramname"><em>affineMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Affine transform points </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_points</td><td>Points to be transformed </td></tr>
    <tr><td class="paramname">out_points</td><td>Transformed points </td></tr>
    <tr><td class="paramname">affineMat</td><td>Input matrix which represents affine transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad06fee097f93efea26e2e496f6b24407" name="ad06fee097f93efea26e2e496f6b24407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06fee097f93efea26e2e496f6b24407">&#9670;&nbsp;</a></span>convertToIntImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTextureProcessFunctionLibrary::convertToIntImage </td>
          <td>(</td>
          <td class="paramtype">UPARAM(ref) TArray&lt; uint8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_rawDataHxWxBGR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_rawDataHxWxBGR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>imageWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>imageHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convert image from byte array to integer array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_rawDataHxWxBGR</td><td>Input image as an array of bytes whose length is (imageHeight x imageWidth x 3(BGR)). </td></tr>
    <tr><td class="paramname">out_rawDataHxWxBGR</td><td>Output image as an array of 32-bit integers whose length is (imageHeight x imageWidth x 3(BGR)). </td></tr>
    <tr><td class="paramname">imageWidth</td><td>The width of the image </td></tr>
    <tr><td class="paramname">imageHeight</td><td>The height of the image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad682284e8f4cbe974051a0f592c9a011" name="ad682284e8f4cbe974051a0f592c9a011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad682284e8f4cbe974051a0f592c9a011">&#9670;&nbsp;</a></span>correctAspectRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTextureProcessFunctionLibrary::correctAspectRatio </td>
          <td>(</td>
          <td class="paramtype">const FVector2D &amp;&#160;</td>
          <td class="paramname"><em>uvScalingFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;&#160;</td>
          <td class="paramname"><em>affineMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;&#160;</td>
          <td class="paramname"><em>correctedAffineMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convert the matrix of affine transform which was calculated in the scaled UV space which keeps the image's aspect ratio to the matrix in the original UV space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uvScalingFactor</td><td>The scaling factor of the UV of the image to keep the aspect ratio of the image. X = 1 and Y &gt; 1 for a landscape image. X &gt; 1 and Y = 1 for a portrait image. </td></tr>
    <tr><td class="paramname">affineMat</td><td>Input matrix </td></tr>
    <tr><td class="paramname">correctedAffineMat</td><td>Output matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bb764699d2d0d0a719327a64798b17e" name="a0bb764699d2d0d0a719327a64798b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb764699d2d0d0a719327a64798b17e">&#9670;&nbsp;</a></span>getImageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTextureProcessFunctionLibrary::getImageSize </td>
          <td>(</td>
          <td class="paramtype">UTexture *&#160;</td>
          <td class="paramname"><em>inputTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVector2D &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the width and the height of a texture </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputTexture</td><td>Input image </td></tr>
    <tr><td class="paramname">dimensions</td><td>Width and height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d8f02132f0e27963372ee18b8cd68a1" name="a9d8f02132f0e27963372ee18b8cd68a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8f02132f0e27963372ee18b8cd68a1">&#9670;&nbsp;</a></span>getInverseAffineMat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTextureProcessFunctionLibrary::getInverseAffineMat </td>
          <td>(</td>
          <td class="paramtype">const FVector2D &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector2D &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;&#160;</td>
          <td class="paramname"><em>out_inverseAffineMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Calculate the matrix of affine transform to crop image </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The center of the image after cropping </td></tr>
    <tr><td class="paramname">orientation</td><td>The normalized vector from the center of the top edge of the image after cropping to the center of the image after cropping. For example, (0, 1) means no rotation, (1, 0) means 90 degree rotation. </td></tr>
    <tr><td class="paramname">size</td><td>The side length of cropped square image </td></tr>
    <tr><td class="paramname">out_inverseAffineMat</td><td>The matrix which transforms the cropped image to the original image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab5b0e53dcf82e3e4c222df0d5acd8f" name="a2ab5b0e53dcf82e3e4c222df0d5acd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab5b0e53dcf82e3e4c222df0d5acd8f">&#9670;&nbsp;</a></span>getInverseAffineMatFrom2Points()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTextureProcessFunctionLibrary::getInverseAffineMatFrom2Points </td>
          <td>(</td>
          <td class="paramtype">const FVector2D &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVector2D &amp;&#160;</td>
          <td class="paramname"><em>topCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>scalingFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_affine_mat2_d.html">FAffineMat2D</a> &amp;&#160;</td>
          <td class="paramname"><em>out_inverseAffineMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Calculate the matrix of affine transform to crop image </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The center of the image after cropping </td></tr>
    <tr><td class="paramname">topCenter</td><td>The center of the top edge of the image after cropping </td></tr>
    <tr><td class="paramname">scalingFactor</td><td>The scaling factor of the cropping. </td></tr>
    <tr><td class="paramname">out_inverseAffineMat</td><td>The matrix which transforms the cropped image to the original image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6644a473f81e2e5b0e790d470771fe07" name="a6644a473f81e2e5b0e790d470771fe07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6644a473f81e2e5b0e790d470771fe07">&#9670;&nbsp;</a></span>showImageWith2dPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTextureProcessFunctionLibrary::showImageWith2dPoints </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; uint8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rawDataHxWxBGR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FVector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlayPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>imageWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>imageHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>700</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString&#160;</td>
          <td class="paramname"><em>windowTitle</em> = <code>&quot;Debug&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>denormalizePoints</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Visualize the image while overlaying points </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawDataHxWxBGR</td><td>Input image as an array of bytes whose length is (imageHeight x imageWidth x 3(BGR)). </td></tr>
    <tr><td class="paramname">overlayPoints</td><td>Points to be drawn on the input image </td></tr>
    <tr><td class="paramname">imageWidth</td><td>The width of the input image </td></tr>
    <tr><td class="paramname">imageHeight</td><td>The height of the input image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad99072ad474d0e52f072ec888645938" name="aad99072ad474d0e52f072ec888645938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad99072ad474d0e52f072ec888645938">&#9670;&nbsp;</a></span>showImageWith3dPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UTextureProcessFunctionLibrary::showImageWith3dPoints </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; uint8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rawDataHxWxBGR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlayPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>imageWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>imageHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>700</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString&#160;</td>
          <td class="paramname"><em>windowTitle</em> = <code>&quot;Debug&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>denormalizePoints</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Visualize the image while overlaying points </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawDataHxWxBGR</td><td>Input image as an array of bytes whose length is (imageHeight x imageWidth x 3(BGR)). </td></tr>
    <tr><td class="paramname">overlayPoints</td><td>Points to be drawn on the input image </td></tr>
    <tr><td class="paramname">imageWidth</td><td>The width of the input image </td></tr>
    <tr><td class="paramname">imageHeight</td><td>The height of the input image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_u_texture_process_function_library.html">UTextureProcessFunctionLibrary</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
